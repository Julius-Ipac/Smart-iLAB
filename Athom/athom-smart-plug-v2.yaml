packages:
  smart-plug-v2:
    url: https://github.com/Cahlil-Togonon/Smart-iLAB
    ref: main
    file: Athom/athom-smart-plug-v2.yaml
    refresh: 5min


globals:
  - id: "relay_state"
    type: std::string


mqtt:
  id: mqtt_sensor
  broker: !secret broker_ip
  port: !secret broker_port
  username: !secret broker_username
  password: !secret broker_password
  
  topic_prefix: null  # removes /state and /command topics
  reboot_timeout: 1min
  
  on_json_message: 
    topic: "athom_smart_plug_v2_${device_id}/relay"
    then: 
       - if: 
          condition: 
            lambda: !lambda |-
              if(x.containsKey("state")){
              if(x["state"] == "On"){
              id(relay_state) = "On";
              return true;
              }
              }
              id(relay_state) = "Off";
              return false;
          then:
            - switch.turn_on: relay
          else: 
            - switch.turn_off: relay


esphome:
  on_boot:
  - priority: -10
    then:
      - lambda: !lambda |-
          id(relay_state) = "Off";
  
      - switch.turn_off: relay


sensor:
  - platform: cse7766
    current:
      name: "Current"
      id: current
      accuracy_decimals: ${sensor_accuracy_decimals}
      filters:
        - throttle_average: ${sensor_update_interval}
        # - lambda: if (x < 0.060) return 0.0; else return x;   #For the chip will report less than 3w power when no load is connected
      on_value_range:
        - above: ${current_limit}
          then:
            - switch.turn_off: relay
    voltage:
      name: "Voltage"
      id: voltage
      accuracy_decimals: ${sensor_accuracy_decimals}
      filters:
        - throttle_average: ${sensor_update_interval}

    power:
      name: "Power"
      id: power_sensor
      accuracy_decimals: ${sensor_accuracy_decimals}
      filters:
        - throttle_average: ${sensor_update_interval}
        # - lambda: if (x < 3.0) return 0.0; else return x;    #For the chip will report less than 3w power when no load is connected

    energy:
      name: "Energy"
      id: energy
      accuracy_decimals: ${sensor_accuracy_decimals}
      unit_of_measurement: kWh
      filters:
        - throttle: ${sensor_update_interval}
        # Multiplication factor from W to kW is 0.001
        - multiply: 0.001
      on_value:
        then:
          - lambda: |-
              static float previous_energy_value = 0.0;
              float current_energy_value = id(energy).state;
              id(total_energy) += current_energy_value - previous_energy_value;
              previous_energy_value = current_energy_value;
              id(total_energy_sensor).update();

  - platform: template
    name: "Total Energy"
    id: total_energy_sensor
    unit_of_measurement: kWh
    device_class: "energy"
    state_class: "total_increasing"
    icon: "mdi:lightning-bolt"
    accuracy_decimals: ${sensor_accuracy_decimals}
    lambda: |-
      return id(total_energy);
    update_interval: never

  - platform: total_daily_energy
    name: "Total Daily Energy"
    id: total_daily_energy_sensor
    restore: true
    power_id: power_sensor
    unit_of_measurement: kWh
    accuracy_decimals: ${sensor_accuracy_decimals}
    filters:
      - multiply: 0.001


script:
  - id: mqtt_publish_sensor_data
    then:
      - lambda: !lambda |-
          id(mqtt_sensor).publish_json("athom_smart_plug_v2_${device_id}/data", [=](JsonObject root){
          
          // timestamp
          root["timestamp"] = id(sntp_time).now().strftime("%Y-%m-%d %X");

          // sensor data
          root["current"] = id(current).state;
          root["energy"] = id(energy).state;
          root["power"] = id(power_sensor).state;
          root["total_daily_energy"] = id(total_daily_energy_sensor).state;
          root["total_energy"] = id(total_energy_sensor).state;
          root["voltage"] = id(voltage).state;

          // relay data
          root["state"] = id(relay_state);
          
          });


time:
  - platform: sntp
    on_time: 
      seconds: /10
      then: 
        - script.execute: mqtt_publish_sensor_data
